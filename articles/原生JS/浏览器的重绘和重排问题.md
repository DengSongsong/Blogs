<p>浏览器重绘或者重排主要在于dom树与渲染树的重新渲染，如果dom树和渲染树构造完毕，浏览器就会显示或者说是绘制页面上的元素。</p>

## 定义
1. dom树(DOM tree)：浏览器把html源代码解析，并且创建一个dom树，每一个html标签在这个dom树上都有一个对应的节点，标签中的文本也有一个对应的文本节点。
2. 渲染树(render tree): 渲染树类似dom树，但是不是一一对应的，渲染树的形成基于样式，即如果某元素有display：none属性，那么该元素不会被呈现在渲染树上，但存在于dom树上。渲染树上的节点被称为一个frame或者一个box。每一个节点都有css box的属性：宽度、高度、边框、外边距等等。
3. 重排：当dom的改变影响了元素的几何属性，例如改变宽高或者在段落中天年文字等行为，浏览器就会重新计算元素的几何属性，而且其他元素的几何属性和位置也会因此受到影响。渲染树上受到影响的部分失效，然后重构渲染树。当重排完毕后，浏览器会在绘制过程中重新绘制页面上受到影响的部分。
4. 重绘：某些属性的修改不会影响几何属性，例如某元素的背景颜色的改变不会影响该元素的高度和宽度。这种情况下，就是重绘，元素的布局没有发生变化。

## 触发重排和重绘的条件

* 添加、删除、更新dom节点
* 通过display: none隐藏一个dom节点
* 通过visibility: hidden隐藏一个dom节点
* 元素的位置改变
* 元素的尺寸改变
* 移动或者给页面中的dom节点添加动画
* 用户行为，例如调整窗口大小，改变字号，或者滚动

## 尽量减少重排和重绘
<p>
原因是重排与重绘的代价较高，影响程序的性能，重排或者是重绘行为会对dom树与渲染树的重新布局，不利于性能的提高。
</p> 

## 减少重排和重绘方法

* 避免一个一个单独的修改属性，批次一次性处理

<p>不推荐做法</p>

```
var el = document.getElementById('demo');
el.style.padding = '10px';
el.style.color = "blue";
el.style.backgroundColor = "black";

```
<p>推荐做法一</p>

```
var el = document.getElementById('demo');
el.style.cssText = 'padding: 10px; color: "blue"; backgroundColor: "black";';

```

<p>推荐做法二</p>

```
el.className += "className";
```
<p>
减少浏览器的重排次数，修改dom使用cssText或者修改css的类名称的方法
</p>

* 把对节点的大量修改操作放在页面外
<p>
元素先脱离文档流，操作完后再带入文档流，用文档碎片(fragment)做处理
</p>

1. 从文档流中提出元素
2. 对其应用多重改变
3. 将元素带回文档中

* 避免大部分页面重排(动画)
1. 使用绝对定位坐标定位页面动画元素，使它位于页面布局流之外
2. 启动元素动画，当它扩大时候，将会临时覆盖部页面。这是一个重绘过程，但是只能影响页面一小部分，避免重排以及重绘一大块也页面
3. 当动画结束时候，重新定位

* 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量
<p>
访问任何类型的dom，当同一个dom属性或者方法被访问同一次以上时，最好使用一个局部变量缓存该dom成员。当遍历一个集合的时候，第一个要优化的就是将集合引用存储在局部变量中，并在循环之外缓存length属性。然后，如果在循环体中多次访问同一个集合元素，那么使用局部变量缓存它
</p>

## 浏览器的处理
<p>
浏览器引擎可能会针对重排做了优化。比如Opera，它会等到有足够数量的变化发生，或者等到一定的时间，或者等一个线程结束，再一起处理，这 样就只发生一次重排。但除了渲染树的直接变化，当获取一些属性时，浏览器为取得正确的值也会触发重排。这样就使得浏览器的优化失效了。这些属性包 括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle() (currentStyle in IE)。所以，在多次使用这些值时应进行缓存。
</p>
