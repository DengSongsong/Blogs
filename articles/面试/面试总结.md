##js

### 一、	函数声明与函数表达式的区别
1.	函数声明以关键字function开头，函数声明必须要用函数名，函数通过函数名来调用，并且函数可以在函数声明前调用，存在声明提升问题，函数声明会提升
2.	函数表达式属于javascript语句中的一部分，变量名可以和函数名相同，函数名也可以无，函数表达式的调用必须声明后调用
3.	声明提升，变量提升只是将定义的变量提升了，初始化的代码没有提升
### 二、	闭包
1.	有权访问另一个函数作用域中的变量的函数，函数在当前词法作用域之外执行函数
2.	外部函数执行后，其整个内部作用域不会被销毁，闭包阻止了这件事情的发生
### 三、	作用域链
1.	全部函数无法查看局部函数的内部细节，但是局部函数可以查看其上层函数细节，直到全部细节。
2.	当需要从局部函数查找某一属性或者方法时，如果当前的作用域中没有找到，就会上溯到上层作用域查找，直至全局函数，这种组织形式就是作用域

### 四、	原型链
1.	js中每一个对象都有一个内置的[prototype]属性，其属性会对其他对象的引用。
2.	原型链定义：相当于对象中的一个内部链接，会引用其他对象。如果在自身对象上没有找到需要的属性或者方法引用，引擎就会在[prototype]关联的对象上进行查找。同理，如果后者中也没有找到需要的引用就会继续查找它的[prototype]

### 五、	this对象
1.	函数中，this的指向与函数的调用环境有关
2.	函数调用时拥有一个上下文对象，this指向这个对象（隐式绑定），然而被隐式绑定的函数会丢失绑定对象(只是对对象的函数的引用)，this会指向window
3.	bind()、apply()、call()直接绑定指定的对象
4.	new绑定到实例对象

### 六、	ajax
1.	全称：异步 javascript 和xml ，用来和服务端进行数据交互，让无刷新替换页面数据成为了可能。
2.	核心对象XmlHttpRequest，一种支持异步请求的技术，通过它可以使用javascript向服务器提出请求并处理响应
var xhr = new XMLHttpRequest(); // 声明一个请求对象
xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){  // readyState 4 代表已向服务器发送请求
        if(xhr.status === OK){ // // status 200 代表服务器返回成功
            console.log(xhr.responseText); // 这是返回的文本
        } else{
            console.log("Error: "+ xhr.status); // 连接失败的时候抛出错误
        }
    }
}

xhr.open('GET', 'xxxx');

// 如何设置请求头? xhr.setRequestHeader(header, value);
xhr.setRequestHeader('Content-Type', 'application/json');

xhr.send(null); // get方法 send null(亦或者不传,则直接是传递 header) ,post 的 send 则是传递值
3.	XMLHttpRequest对象的三个常用属性
3.1	onreadystatechange：存在有处理服务器响应的函数
3.2	readyState：存有服务器响应的状态信息。每当readyState改变时，onreadystatechange函数就会被执行
readyState属性可能的值：
0 请求未初始化（在调用open()之前）
1 请求已提出（调用send（）之前）
2 请求已发送 （这里通常可以从响应得到内容头部）
3 请求处理中（响应中通常有部分数据可用，但是服务器还没有完成响应）
4 请求已完成（可以访问服务器响应并使用它）
4.	XMLHttpRequest对象的方法
4.1	open(‘method’, ‘url’, [sayncFlag]) method可以为get、post、put  建立对服务器的调用
4.2	setRequestHeader(“header”,”value”) 把指定首部设置为所提供的值 设置请求头
4.3	send(conetnt) 向服务器发送请求 
5.	ajax编程步骤
5.1	创建xmlHttpRequest 对象 new xmlHttpRequest
5.2	设置请求方式  通过open()
5.3	调用回调函数  onreadystatechange
5.4	发送请求  send()
6.	状态码
6.1	1**：请求收到，继续处理
6.2	2**： 操作成功收到，分析、接受 成功处理了请求状态
         200 服务器已经成功处理请求，并提供了请求的网页
			201 用户新建或修改数据成功
         202 一个请求已经进入后台
         204 用户删除成功
6.3	3**：完成此请求必须进一步处理 每次请求使用的重定向不要超过5次
304 网页上次请求没有更新，节省带宽和开销
6.4	4**：请求包含一个错误语法或不能完成
400 服务器不理解请求的语法
401 用户没有权限（用户名，密码输入错误）
403 用户得到授权（401相反），但是访问被禁止
404 服务器找不到请求的网页，
6.5	5**：服务器执行一个完全有效请求失败
500——服务器产生内部错误
501——服务器不支持请求的函数
502——服务器暂时不可用，有时是为了防止发生系统过载 服务器目前无法使用
503——服务器过载或暂停维修
504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长
505——服务器不支持或拒绝支请求头中指定的HTTP版本

### 七、	js中的数据类型
1. 7种数据类型：Boolean、null、undefined、number、String、symbol(es6)、object
2. 5种基本类型：Boolean、null、undefined、number、String
3. 引用类型：object
4. null是一种特殊的对象

### 八、	跨域问题
1.	同源：域名、协议、端口均相同
2.	同源策略：一种约定，是浏览器最核心最基本的安全功能，如果缺少了同源策略，浏览器很容易受到xss，CSFR等攻击。
3.	跨域：指一个域下的文档或者脚本试图去请求另一个域下的资源
4.	跨域问题：javascript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源
5.	解决方案：
5.1 jsonp：通过动态创建script标签，然后利用src属性进行跨域   ajax库
			JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。
5.2 服务器代理：浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端
5.3 document.domain + iframe(此方案仅限于主域相同，子域不同的跨域应用场景)：两个页面都通过强制设置document.domain为基础主域，就实现了同域
5.4 nginx反向代理接口跨域：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录
### 九、new操作符具体干了什么呢
1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2. 属性和方法被加入到 this 引用的对象中。
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this 。
### 十、内存泄漏
1. 指任何对象在您不再拥有或需要它之后仍然存在（例如：setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏）

### 十一、从我们在地址栏输入url到网页渲染完成都经历了什么
1. 输入URL 
2. 浏览器查询域名IP地址 
3. 浏览器发送HTTP请求到服务器 
4. 服务器发送重定向到浏览器 
5. 浏览器重新发送HTTP请求到重定向地址 
6. 服务器处理HTTP请求 
7. 服务器发送响应到浏览器 
8. 浏览器根据响应结果渲染页面 
9. 浏览器发送请求获取嵌入HTML页面对象请求 
10. 浏览器发送异步请求

### 十二、浏览器数据持久化存储技术
1.	http文件缓存  304
基于http协议的浏览器端文件级缓存机制。在文件重复请求的情况下，浏览器可以根据http响应的协议头信息判断是从服务器端请求文件还是从本地读取文件  加快页面资源加载，同时节省网路流量
2.	loaclStorage
html5的一种本地缓存方案，目前主要用于浏览器保存体积较大的数据，数据永久保存在客户端
3.	sessionStorage
和localStorage的功能相似，但是sessionStorage在浏览器关闭时会自动清空，不能进行客户端的持久化数据存储
4.	cookie
网站为了辨别用户身份或者Session跟踪而存储在用户浏览器端的数据。Cookie信息一般会通过http请求发送的服务器端，最大长度限制为4kb
   Session Cookie：一般不会设置过期时间，cookie的生命周期为浏览器会话期间，只要关闭浏览器窗口
持久化cookie：一般会设置过期时间，而且浏览器会将持久型cookie的信息保存到硬盘上，关闭后再打开浏览器，这些cookie依然有效，直到超过设定的过期时间或被清空
5.	WebSQL
浏览器用于存储较大量数据的缓存机制，允许sql语句查询，实现小型数据库存储功能，不是html5规范的组成部分
6.	IndexDB
可在客户端存储大量结构化数据并且能在这些数据上使用索引进行高效能检索的一条api，大小限制通常约为50MB，可以将大量数据保存在本地，但可以会造成数据泄露
7.	Application Cache
允许浏览器通过manifest配置文件在本地有选择性的存储javascript、css、图片等资源的文件级缓存机制
8.	Session
在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中
### 十三、commonJS、 cmd、amd、ES6export
1.	CommonJS是node.js中的模块化规范，它有四个重要的环境变量为模块化的实现提供支持：module、exports、require、global。用module.exports定义当前模块对外输出的接口（不推荐直接用exports），用require加载模块
2.	AMD采用的是异步方式加载模块，模块的加载不影响他后面语句的运行。所有的依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。用require.js实现AMD规范的模块化：用require.config()指定引用路径等，用define()定义模块，用require()加载模块
3.	CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。
4.	ES6中其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能
5.	ES6 模块与 CommonJS 模块的差异：1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
### 十四、promise
1.	是一个对象，从它可以获取异步操作的消息，保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
2.	对象的状态不受外界影响。Promise对象代表一个异步操作，有3种状态：Pending(进行中)、Fulfilled(已成功)和Rejected(已失败)。
3.	一旦状态改变就不会再变，任何时候都可以得到这个结果。
4.	有了promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。
5.	Promise对象是一个构造函数，用来生成promise实例。构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject，这两个参数是两个函数，由javascript引擎提供。
6.	Resolve函数的作用是将promise对象的状态从“未完成”变为“成功”，在异步操作成功时调用，并将异步操作的结果作为参数传递出去。Reject函数的作用是将promise对象的状态从“未完成”变为“失败”，在异步操作失败时调用，并将异步操作报出的错误作为参数传递出去。
7.	Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。then方法可以接受两个回调函数作为参数。第一个回调函数是promise对象的状态变为resolved时调用，第二个回调函数是promise对象的状态变为rejected时调用，其中第二个函数是可选的。这两个函数都接受promise对象传出的值作为参数
### 十五、函数节流
1.	作用：限制事件的频繁触发，dom操作比起非dom交互需要更多的内存和cpu时间，连续尝试进行过多的dom相关操作可能会导致浏览器挂起，有时候甚至会崩溃。
2.	原理：如果你持续触发事件，每隔一段时间，只执行一次事件。
3.	方法：
3.1.	使用定时器：当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器
3.2.	使用时间戳：当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行
### 十六、函数防抖
1.	作用：限制事件的频繁触发
2.	原理：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行
### 十七、call()、apply()、bind()
1.	作用：都是用来改变方法的this关键字
2.	call(): 接受多个参数，第一个参数为this对象，其余参数都可直接传递给函数，传递的参数必须逐个列举出来
3.	apply()：接收两个参数，第一个参数为this对象，第二个参数为数组，或Array实例，也可以为arguments对象
4.	bind()：会创建一个函数的实例，其this值会被绑定到传给bind()函数的值  ES5


## CSS
### 一、	box-sizing 盒模型
1.	border-box:width = content + padding + border
2.	content-box:默认值，盒子的宽度只包括content的宽度
盒子总宽度：margin+border+padding+width
### 二、	清除浮动
1.	生成BFC overflow:hidden
2.	增加子元素使用 clear:both
3.	父元素使用伪类 clear:both
### 三、	元素分类
1.	块状元素：<div>、 <p>、<h1>、<form>、<ul> 和 <li>
2.	内联元素（行内元素）：<span>、<a>、<label>、<input>、 <img>、 <strong> 和<em>
### 四、	居中
1.	元素水平居中：
1.1．	行内元素水平居中：行内元素包裹在display:block的父层元素中，父元素text-align:center
1.2．	块状元素水平居中：元素 margin: 0 auto
1.3．	多个块状元素水平居中：内部div设置为内联块display:inline-block,父元素text-align:center
2.	元素垂直居中
2.1.	单行内元素垂直居中：设置行内元素行高(line-height)为父元素的高度或者包裹块的高度。
2.2.	多行的行内元素垂直居中：让包裹模拟表格单元display:table-cell，然后用vertical-align:middle进行控制位置
2.3.	块状元素垂直居中（已知高度）：
Div{
	Position:absolute;
	Top:50%;
	Left:50%;
	Height:h px;
	Width:w px;
	Margin-top:-h/2 px;
}
2.4.	已知宽高元素水平垂直居中：
2.4.1.	position:absoluete;top:50%;left:50%;margin:-h/2px 0 0 –w/2 px
2.5.	块状已知高元素水平垂直居中: 父元素display:flex 子元素margin:auto
2.6.	未知宽高元素实现水平垂直居中
2.6.1.	Position:absolute;top:50%;left:50%; transform: translate(-50%,-50%);
2.6.2.	Display:flex; align-items: center; justify-content: center;
### 五、	CSS权重
!important > 行内样式 > id > class > tag 权重可以叠加

## HTML
### 一、	meta viewport设置移动端自适应 
1.	<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
2.	viewport 设备屏幕上用来显示网页的那部分区域，也就是浏览器上用来显示网页的那部分区域，但不局限于浏览器可视区域的大小，可能比浏览器的可视区域大，也可能小
### 二、	页面导入样式时，使用link和@import有什么区别？
1.	link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;
2.	页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载
3.	import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题
